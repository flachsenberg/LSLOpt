/*
 * This file was autogenerated
 * from <class 'splines.LJLike.LJLike'> on 2019-05-31 by flachsenberg.
 *
 * THIS FILE IS COMPLETELY AUTOGENERATED!
 * DO NOT EDIT!
 */

#include <limits>
#include "LJLike_0.hpp"


namespace AutoGeneratedSplines {
namespace LJLike_0 {

inline double get_a0(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return y0;
}

inline double get_a1(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return 3*(-2*std::pow(x1, 2)*y0 + 2*std::pow(x1, 2)*y2 + 4*x1*x2*y0 - 3*x1*x2*y2
      - 2*std::pow(x2, 2)*y0)/(std::pow(x1, 5)*(std::pow(x1, 2) - 2*x1*x2 + std::pow(x2,
      2)));
}

inline double get_b1(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return 3*(5*std::pow(x1, 2)*y0 - 5*std::pow(x1, 2)*y2 - 10*x1*x2*y0 + 7*x1*x2*y2
      + 5*std::pow(x2, 2)*y0)/(std::pow(x1, 4)*(std::pow(x1, 2) - 2*x1*x2 + std::pow(x2,
      2)));
}

inline double get_c1(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return (-10*std::pow(x1, 2)*y0 + 9*std::pow(x1, 2)*y2 + 20*x1*x2*y0 - 12*x1*x2*y2
      - 10*std::pow(x2, 2)*y0)/(std::pow(x1, 3)*(std::pow(x1, 2) - 2*x1*x2 + std::pow(x2,
      2)));
}

inline double get_d1(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return 0;
}

inline double get_e1(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return 0;
}

inline double get_g1(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return y0;
}

inline double get_a2(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return -y2/(std::pow(x1, 3) - 3*std::pow(x1, 2)*x2 + 3*x1*std::pow(x2, 2) - std::pow(x2,
      3));
}

inline double get_b2(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return 3*x2*y2/(std::pow(x1, 3) - 3*std::pow(x1, 2)*x2 + 3*x1*std::pow(x2, 2) -
      std::pow(x2, 3));
}

inline double get_c2(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return -3*std::pow(x2, 2)*y2/(std::pow(x1, 3) - 3*std::pow(x1, 2)*x2 + 3*x1*std::pow(x2,
      2) - std::pow(x2, 3));
}

inline double get_d2(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return x1*y2*(std::pow(x1, 2) - 3*x1*x2 + 3*std::pow(x2, 2))/(std::pow(x1, 3) -
      3*std::pow(x1, 2)*x2 + 3*x1*std::pow(x2, 2) - std::pow(x2, 3));
}

inline double get_a3(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return 6*y2/(std::pow(x2, 5) - 5*std::pow(x2, 4)*x3 + 10*std::pow(x2, 3)*std::pow(x3,
      2) - 10*std::pow(x2, 2)*std::pow(x3, 3) + 5*x2*std::pow(x3, 4) - std::pow(x3,
      5));
}

inline double get_b3(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return -15*y2*(x2 + x3)/(std::pow(x2, 5) - 5*std::pow(x2, 4)*x3 + 10*std::pow(x2,
      3)*std::pow(x3, 2) - 10*std::pow(x2, 2)*std::pow(x3, 3) + 5*x2*std::pow(x3,
      4) - std::pow(x3, 5));
}

inline double get_c3(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return 10*y2*(std::pow(x2, 2) + 4*x2*x3 + std::pow(x3, 2))/(std::pow(x2, 5) - 5*std::pow(x2,
      4)*x3 + 10*std::pow(x2, 3)*std::pow(x3, 2) - 10*std::pow(x2, 2)*std::pow(x3,
      3) + 5*x2*std::pow(x3, 4) - std::pow(x3, 5));
}

inline double get_d3(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return -30*x2*x3*y2*(x2 + x3)/(std::pow(x2, 5) - 5*std::pow(x2, 4)*x3 + 10*std::pow(x2,
      3)*std::pow(x3, 2) - 10*std::pow(x2, 2)*std::pow(x3, 3) + 5*x2*std::pow(x3,
      4) - std::pow(x3, 5));
}

inline double get_e3(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return 30*std::pow(x2, 2)*std::pow(x3, 2)*y2/(std::pow(x2, 5) - 5*std::pow(x2,
      4)*x3 + 10*std::pow(x2, 3)*std::pow(x3, 2) - 10*std::pow(x2, 2)*std::pow(x3,
      3) + 5*x2*std::pow(x3, 4) - std::pow(x3, 5));
}

inline double get_g3(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return -std::pow(x3, 3)*y2*(10*std::pow(x2, 2) - 5*x2*x3 + std::pow(x3, 2))/(std::pow(x2,
      5) - 5*std::pow(x2, 4)*x3 + 10*std::pow(x2, 3)*std::pow(x3, 2) - 10*std::pow(x2,
      2)*std::pow(x3, 3) + 5*x2*std::pow(x3, 4) - std::pow(x3, 5));
}

inline double get_a4(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3) {
  return 0;
}

Spline::Spline(
    const double& y0,
    const double& x1,
    const double& x2,
    const double& y2,
    const double& x3)
: y0(y0)
, x1(x1)
, x2(x2)
, y2(y2)
, x3(x3) {
  // coefficients for function f0
  a0 = get_a0(y0, x1, x2, y2, x3);
  // coefficients for function f1
  g1 = get_g1(y0, x1, x2, y2, x3);
  e1 = get_e1(y0, x1, x2, y2, x3);
  d1 = get_d1(y0, x1, x2, y2, x3);
  c1 = get_c1(y0, x1, x2, y2, x3);
  b1 = get_b1(y0, x1, x2, y2, x3);
  a1 = get_a1(y0, x1, x2, y2, x3);
  // coefficients for function f2
  d2 = get_d2(y0, x1, x2, y2, x3);
  c2 = get_c2(y0, x1, x2, y2, x3);
  b2 = get_b2(y0, x1, x2, y2, x3);
  a2 = get_a2(y0, x1, x2, y2, x3);
  // coefficients for function f3
  g3 = get_g3(y0, x1, x2, y2, x3);
  e3 = get_e3(y0, x1, x2, y2, x3);
  d3 = get_d3(y0, x1, x2, y2, x3);
  c3 = get_c3(y0, x1, x2, y2, x3);
  b3 = get_b3(y0, x1, x2, y2, x3);
  a3 = get_a3(y0, x1, x2, y2, x3);
  // coefficients for function f4
  a4 = get_a4(y0, x1, x2, y2, x3);

  // then the (potentially depended) symbols
  j_f0_f1 = 0;
  j_f1_f2 = x1;
  j_f2_f3 = x2;
  j_f3_f4 = x3;

  // the sampling points
  s_f0_0_d0_x = 0;
  s_f0_0_d0_y = y0;
  s_f2_0_d0_x = x1;
  s_f2_0_d0_y = 0;
  s_f2_1_d0_x = x2;
  s_f2_1_d0_y = y2;
  s_f2_2_d1_x = x2;
  s_f2_2_d1_y = 0;
  s_f2_3_d2_x = x2;
  s_f2_3_d2_y = 0;
  s_f4_0_d0_x = x3;
  s_f4_0_d0_y = 0;
}

bool Spline::areJunctionsIncreasing() const {
  // no equality allowed, each function must be evaluated somewhere
  if (j_f0_f1 >= j_f1_f2) { return false; }
  if (j_f1_f2 >= j_f2_f3) { return false; }
  if (j_f2_f3 >= j_f3_f4) { return false; }
  return true;
}

bool Spline::areSamplingPointsWithinRange(const double& epsilon) const {
  // we do epsilon comparison here because small deviations of the sampling
  // points and the junctions can happen and are no problem
  if (s_f0_0_d0_x > j_f0_f1 + epsilon) { return false; }
  if (s_f2_0_d0_x < j_f1_f2 - epsilon) { return false; }
  if (s_f2_1_d0_x < j_f1_f2 - epsilon) { return false; }
  if (s_f2_0_d0_x > j_f2_f3 + epsilon) { return false; }
  if (s_f2_1_d0_x > j_f2_f3 + epsilon) { return false; }
  if (s_f4_0_d0_x < j_f3_f4 - epsilon) { return false; }
  return true;
}

bool Spline::areSamplingPointsFulfilled(const double& epsilon) const {
  if (std::abs(eval<0>(s_f0_0_d0_x) - s_f0_0_d0_y) > epsilon) { return false; }
  if (std::abs(eval<0>(s_f2_0_d0_x) - s_f2_0_d0_y) > epsilon) { return false; }
  if (std::abs(eval<0>(s_f2_1_d0_x) - s_f2_1_d0_y) > epsilon) { return false; }
  if (std::abs(eval<1>(s_f2_2_d1_x) - s_f2_2_d1_y) > epsilon) { return false; }
  if (std::abs(eval<2>(s_f2_3_d2_x) - s_f2_3_d2_y) > epsilon) { return false; }
  if (std::abs(eval<0>(s_f4_0_d0_x) - s_f4_0_d0_y) > epsilon) { return false; }
  return true;
}


bool Spline::isValid(const double& epsilon) const {
  // check if additional constraints are satisified
  if (!(y0 > 0)) { return false; }
  if (!(y2 <= 0)) { return false; }
  // check if the values are valid
  if (!std::isfinite(a0)) { return false; }
  if (!std::isfinite(a1)) { return false; }
  if (!std::isfinite(b1)) { return false; }
  if (!std::isfinite(c1)) { return false; }
  if (!std::isfinite(d1)) { return false; }
  if (!std::isfinite(e1)) { return false; }
  if (!std::isfinite(g1)) { return false; }
  if (!std::isfinite(a2)) { return false; }
  if (!std::isfinite(b2)) { return false; }
  if (!std::isfinite(c2)) { return false; }
  if (!std::isfinite(d2)) { return false; }
  if (!std::isfinite(a3)) { return false; }
  if (!std::isfinite(b3)) { return false; }
  if (!std::isfinite(c3)) { return false; }
  if (!std::isfinite(d3)) { return false; }
  if (!std::isfinite(e3)) { return false; }
  if (!std::isfinite(g3)) { return false; }
  if (!std::isfinite(a4)) { return false; }
  if (!std::isfinite(j_f0_f1)) { return false; }
  if (!std::isfinite(j_f1_f2)) { return false; }
  if (!std::isfinite(j_f2_f3)) { return false; }
  if (!std::isfinite(j_f3_f4)) { return false; }

  if (!areJunctionsIncreasing()) {
    return false;
  }

  if (!areSamplingPointsWithinRange(epsilon)) {
    return false;
  }

  if (!areSamplingPointsFulfilled(epsilon)) {
    return false;
  }

  if (!isContinuous_dxN(2, epsilon)) {
    return false;
  }
  return true;
}

double Spline::eval_dx0(const double& x) const {
  return eval<0>(x);
}

double Spline::eval_dx1(const double& x) const {
  return eval<1>(x);
}

double Spline::eval_dx2(const double& x) const {
  return eval<2>(x);
}

double Spline::eval_dx3(const double& x) const {
  return eval<3>(x);
}

double Spline::eval_dxN(
     const double& x,
     const std::size_t& n) const {
  switch(n) {
    case 0: return eval<0>(x);
    case 1: return eval<1>(x);
    case 2: return eval<2>(x);
    case 3: return eval<3>(x);
    case 4: return eval<4>(x);
    case 5: return eval<5>(x);
    default: return 0.0;
  }
}

bool Spline::isContinuous_dxN(
     const std::size_t& n,
     const double& epsilon) const {
  if (!is_continuous<0>(epsilon)) { return false; }
  if (!is_continuous<1>(epsilon)) { return n < 1; }
  if (!is_continuous<2>(epsilon)) { return n < 2; }
  if (!is_continuous<3>(epsilon)) { return n < 3; }
  if (!is_continuous<4>(epsilon)) { return n < 4; }
  if (!is_continuous<5>(epsilon)) { return n < 5; }
  return true;
}

inline std::pair<double, double> Spline::getCutoff(const double& epsilon) const {
  double lower = -std::numeric_limits<double>::infinity();
  double upper = std::numeric_limits<double>::infinity();

  /* todo:
   * This function currently only looks at the first and the last function. The reason is
   * that the function must be strictly 0 degree, i.e. for functions with higher
   * polynomials the x-dependend terms must be strictly 0.0 or the complete interval
   * would have to be checked/sampled.
   * Therefore, this heuristic only looks at the first/last function and the resulting
   * cutoff interval might be too wide. However, this should pose no problems
   * in practice and is definitely better than reporting a false narrow interval.
   */
  if (std::abs(a0) <= epsilon) {
    lower = j_f0_f1;
  }
  if (std::abs(a4) <= epsilon) {
    upper = j_f3_f4;
  }

  return {lower, upper};
}

void Spline::print(std::ostream& os) const {
  os << "f0: "
     << "a0=" << a0 << std::endl;
  os << "f1: "
     << "a1=" << a1 << ','
     << "b1=" << b1 << ','
     << "c1=" << c1 << ','
     << "d1=" << d1 << ','
     << "e1=" << e1 << ','
     << "g1=" << g1 << std::endl;
  os << "f2: "
     << "a2=" << a2 << ','
     << "b2=" << b2 << ','
     << "c2=" << c2 << ','
     << "d2=" << d2 << std::endl;
  os << "f3: "
     << "a3=" << a3 << ','
     << "b3=" << b3 << ','
     << "c3=" << c3 << ','
     << "d3=" << d3 << ','
     << "e3=" << e3 << ','
     << "g3=" << g3 << std::endl;
  os << "f4: "
     << "a4=" << a4 << std::endl;
  os << "j_f0_f1: " << j_f0_f1 << std::endl;
  os << "j_f1_f2: " << j_f1_f2 << std::endl;
  os << "j_f2_f3: " << j_f2_f3 << std::endl;
  os << "j_f3_f4: " << j_f3_f4 << std::endl;
  os << "s_f0_0_d0: " << "x=" << s_f0_0_d0_x << ",y=" << s_f0_0_d0_y
     << ",n=" << 0 << std::endl;
  os << "s_f2_0_d0: " << "x=" << s_f2_0_d0_x << ",y=" << s_f2_0_d0_y
     << ",n=" << 0 << std::endl;
  os << "s_f2_1_d0: " << "x=" << s_f2_1_d0_x << ",y=" << s_f2_1_d0_y
     << ",n=" << 0 << std::endl;
  os << "s_f2_2_d1: " << "x=" << s_f2_2_d1_x << ",y=" << s_f2_2_d1_y
     << ",n=" << 1 << std::endl;
  os << "s_f2_3_d2: " << "x=" << s_f2_3_d2_x << ",y=" << s_f2_3_d2_y
     << ",n=" << 2 << std::endl;
  os << "s_f4_0_d0: " << "x=" << s_f4_0_d0_x << ",y=" << s_f4_0_d0_y
     << ",n=" << 0 << std::endl;
  os << "output: " << std::endl;
}

}
}
