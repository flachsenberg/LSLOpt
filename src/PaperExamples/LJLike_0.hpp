/*
 * This file was autogenerated
 * from <class 'splines.LJLike.LJLike'> on 2019-05-31 by flachsenberg.
 *
 * THIS FILE IS COMPLETELY AUTOGENERATED!
 * DO NOT EDIT!
 */

#pragma once
#include <cmath>
#include "AutoGeneratedSpline.hpp" // ok, you may edit this line...


namespace AutoGeneratedSplines {
namespace LJLike_0 {

/*
 *
 * *** Auto-generated piecewise polynomial function. ***
 *
 * The spline was constructed and the initial C++ was generated using
 * sympy 1.3 (https://www.sympy.org/).
 * The equations were internally solved using
 * sympy 1.3.
 *
 * The problem consisted of 18 free variables and 18 constraints.
 *
 * This is solution 1/1.
 *
 * The function is in differentiability class $C^{2}$.
 * The continuity conditions are not listed below.
 *
 * The function is built from 5 polynomials.
 *
 * Input variables:
 *   $y_{0}, x_{1}, x_{2}, y_{2}, x_{3}$
 *
 * Domains of polynomials:
 *   $-\infty < x \leq j_{f_{0},f_{1}}: f_{0}(x)$
 *   $j_{f_{0},f_{1}} < x \leq j_{f_{1},f_{2}}: f_{1}(x)$
 *   $j_{f_{1},f_{2}} < x \leq j_{f_{2},f_{3}}: f_{2}(x)$
 *   $j_{f_{2},f_{3}} < x \leq j_{f_{3},f_{4}}: f_{3}(x)$
 *   $j_{f_{3},f_{4}} < x < \infty: f_{4}(x)$
 *
 * Junction points:
 *   $j_{f_{0},f_{1}} = 0$
 *   $j_{f_{1},f_{2}} = x_{1}$
 *   $j_{f_{2},f_{3}} = x_{2}$
 *   $j_{f_{3},f_{4}} = x_{3}$
 *
 * Polynomials:
 *   $f_{0}(x) = a_{0}$
 *   $f_{1}(x) = a_{1} x^{5} + b_{1} x^{4} + c_{1} x^{3} + d_{1} x^{2} + e_{1} x + g_{1}$
 *   $f_{2}(x) = a_{2} x^{3} + b_{2} x^{2} + c_{2} x + d_{2}$
 *   $f_{3}(x) = a_{3} x^{5} + b_{3} x^{4} + c_{3} x^{3} + d_{3} x^{2} + e_{3} x + g_{3}$
 *   $f_{4}(x) = a_{4}$
 *
 * Additional output variables:
 *   No additional output variables.
 *
 * Sampling points:
 *   $f(0) = y_{0}$
 *   $f(x_{1}) = 0$
 *   $f(x_{2}) = y_{2}$
 *   $f'(x_{2}) = 0$
 *   $f''(x_{2}) = 0$
 *   $f(x_{3}) = 0$
 *
 * Input constraints:
 *   $y_{0} > 0$
 *   $y_{2} \leq 0$
 *
 *
 * Exemplary plot of the piecewise polynomial function:
 *

     +--------------------------------------------------------------------------+
     |                                                                          |
     |                                                     f(x): LJLike ******* |
     |                                                                          |
     |                                                                          |
     |*******************                                                       |-+y0
     |                  ***                                                     |
     |                     **                                                   |
     |                      **                                                  |
     |                        *                                                 |
     |                        **                                                |
     |                         **                                               |
     |                          **                                              |
     |                           *                                              |
     |                            *                                             |
     |                            **                                            |
     |                             *                                            |
     |                              *                                           |
     |                              **                                          |
     |                               *                                          |
     |                               **                                         |
     |                                *                                         |
     |                                **                                        |
     |                                 *                                        |
     |                                  *                                       |
     |                                  **                                      |
     |                                   *                                      |
     |                                    *                                     |
 0 +-|                                     *                 *******************|
     |                                      **          ******                  |
     |                                       ************                       |-+y2
     |                                                                          |
     |                                                                          |
     |                                                                          |
     |                                                                          |
     +--------------------------------------------------------------------------+
                +                          +     +                    +
                0                         x1    x2                   x3


 *
 */

struct Spline : public AutoGeneratedSpline {
  // Construct a new spline with the given input parameters.
  Spline(
      const double& y0,
      const double& x1,
      const double& x2,
      const double& y2,
      const double& x3);

  /* Very important function that checks if the spline is valid!
   * Never use a spline without checking first!
   * It checks that all values are valid (i.e. neither infinite nor NaN).
   * Futhermore it validates, that the junctions are strictly monotonically
   * increasing, that all sampling points are located within the domain of
   * the respective function, that all sampling points are fulfilled and
   * finally that the spline is of the claimed differentiability class.
   * The epsilon value is used to allow for small numerical inaccuracies.
   */
  virtual bool isValid(const double& epsilon) const override;

  /* Evaluate the N-th derivative of the function.
   * The runtime of the function is T_eval = O(p + log F) with
   * p = maximal degree of a polynomials and F = the number of functions in the spline.
   * The active function at point x is determined using a binary search (hence log F)
   * and the evaluation time is linear in the polynomial degree.
   */
  template<std::size_t N> double eval(const double& x) const;

  /* This function calls eval<0>(x) and is a virtual convenience function that
   * is accessibly via the interface base class.*/
  virtual double eval_dx0(const double& x) const override;

  /* This function calls eval<1>(x) and is a virtual convenience function that
   * is accessibly via the interface base class.*/
  virtual double eval_dx1(const double& x) const override;

  /* This function calls eval<2>(x) and is a virtual convenience function that
   * is accessibly via the interface base class.*/
  virtual double eval_dx2(const double& x) const override;

  /* This function calls eval<3>(x) and is a virtual convenience function that
   * is accessibly via the interface base class.*/
  virtual double eval_dx3(const double& x) const override;

  /* This function is a convenience function for eval<N> accessibly via the base class.
   * However, this function is linear in n because the appropriate function must
   * be selected first. */
  virtual double eval_dxN(const double& x, const std::size_t& n) const override;

  /* Get cutoff values, i.e. the upper and lower value where the function gets and stay 0.0.
   * Please note that this function only checks the first/last function and therefore
   * the cutoff interval may be too large. This will only happen in degenerate cases. */
  virtual std::pair<double, double> getCutoff(const double& epsilon) const override;

  // check if the function is continuous up to the N-th derivative (runtime linear in N)
  virtual bool isContinuous_dxN(const std::size_t& n, const double& epsilon) const override;

  // check if the N-th derivative is continuous
  template<std::size_t N> double is_continuous(const double& epsilon) const;

  // *** The following functions/members should not be considered to be part of the interface! ***
  // *** They may be accessed without any problems but the interface may change in the future! ***

  // check if the junctions are strictly monotonically increasing
  bool areJunctionsIncreasing() const;

  // check if all the sampling points lie within the domain of the polynomial
  bool areSamplingPointsWithinRange(const double& epsilon) const;

  // check if all sampling points are fulfilled by the spline
  bool areSamplingPointsFulfilled(const double& epsilon) const;

  // print the parameters to the `std::ostream`
  virtual void print(std::ostream& os) const override;

  /* Evaluate the function f0 at the given point x.
   * Please note, that this function should usually not be called,
   * but the function `eval<N>` that automatically selects the correct function.
   * This function template is specialized below for the calculation of each non-zero derivative.*/
  template<std::size_t N> double _eval_f0(const double& x) const {{ return 0.0; }}
  /* Evaluate the function f1 at the given point x.
   * Please note, that this function should usually not be called,
   * but the function `eval<N>` that automatically selects the correct function.
   * This function template is specialized below for the calculation of each non-zero derivative.*/
  template<std::size_t N> double _eval_f1(const double& x) const {{ return 0.0; }}
  /* Evaluate the function f2 at the given point x.
   * Please note, that this function should usually not be called,
   * but the function `eval<N>` that automatically selects the correct function.
   * This function template is specialized below for the calculation of each non-zero derivative.*/
  template<std::size_t N> double _eval_f2(const double& x) const {{ return 0.0; }}
  /* Evaluate the function f3 at the given point x.
   * Please note, that this function should usually not be called,
   * but the function `eval<N>` that automatically selects the correct function.
   * This function template is specialized below for the calculation of each non-zero derivative.*/
  template<std::size_t N> double _eval_f3(const double& x) const {{ return 0.0; }}
  /* Evaluate the function f4 at the given point x.
   * Please note, that this function should usually not be called,
   * but the function `eval<N>` that automatically selects the correct function.
   * This function template is specialized below for the calculation of each non-zero derivative.*/
  template<std::size_t N> double _eval_f4(const double& x) const {{ return 0.0; }}

  // input parameters
  double y0;
  double x1;
  double x2;
  double y2;
  double x3;

  // coefficients for function f0
  double a0;
  // coefficients for function f1
  double a1;
  double b1;
  double c1;
  double d1;
  double e1;
  double g1;
  // coefficients for function f2
  double a2;
  double b2;
  double c2;
  double d2;
  // coefficients for function f3
  double a3;
  double b3;
  double c3;
  double d3;
  double e3;
  double g3;
  // coefficients for function f4
  double a4;

  // junctions between the functions
  double j_f0_f1;
  double j_f1_f2;
  double j_f2_f3;
  double j_f3_f4;

  // sampling points
  double s_f0_0_d0_x;
  double s_f0_0_d0_y;
  double s_f2_0_d0_x;
  double s_f2_0_d0_y;
  double s_f2_1_d0_x;
  double s_f2_1_d0_y;
  double s_f2_2_d1_x;
  double s_f2_2_d1_y;
  double s_f2_3_d2_x;
  double s_f2_3_d2_y;
  double s_f4_0_d0_x;
  double s_f4_0_d0_y;
};

// template specialization for non-zero derivative 0 of function f0
template<> inline double Spline::_eval_f0<0>(const double& x) const {
  return a0;
}

// template specialization for non-zero derivative 0 of function f1
template<> inline double Spline::_eval_f1<0>(const double& x) const {
  return a1*std::pow(x, 5) + b1*std::pow(x, 4) + c1*std::pow(x, 3) + d1*std::pow(x,
      2) + e1*x + g1;
}

// template specialization for non-zero derivative 1 of function f1
template<> inline double Spline::_eval_f1<1>(const double& x) const {
  return 5*a1*std::pow(x, 4) + 4*b1*std::pow(x, 3) + 3*c1*std::pow(x, 2) + 2*d1*x
      + e1;
}

// template specialization for non-zero derivative 2 of function f1
template<> inline double Spline::_eval_f1<2>(const double& x) const {
  return 20*a1*std::pow(x, 3) + 12*b1*std::pow(x, 2) + 6*c1*x + 2*d1;
}

// template specialization for non-zero derivative 3 of function f1
template<> inline double Spline::_eval_f1<3>(const double& x) const {
  return 60*a1*std::pow(x, 2) + 24*b1*x + 6*c1;
}

// template specialization for non-zero derivative 4 of function f1
template<> inline double Spline::_eval_f1<4>(const double& x) const {
  return 120*a1*x + 24*b1;
}

// template specialization for non-zero derivative 5 of function f1
template<> inline double Spline::_eval_f1<5>(const double& x) const {
  return 120*a1;
}

// template specialization for non-zero derivative 0 of function f2
template<> inline double Spline::_eval_f2<0>(const double& x) const {
  return a2*std::pow(x, 3) + b2*std::pow(x, 2) + c2*x + d2;
}

// template specialization for non-zero derivative 1 of function f2
template<> inline double Spline::_eval_f2<1>(const double& x) const {
  return 3*a2*std::pow(x, 2) + 2*b2*x + c2;
}

// template specialization for non-zero derivative 2 of function f2
template<> inline double Spline::_eval_f2<2>(const double& x) const {
  return 6*a2*x + 2*b2;
}

// template specialization for non-zero derivative 3 of function f2
template<> inline double Spline::_eval_f2<3>(const double& x) const {
  return 6*a2;
}

// template specialization for non-zero derivative 0 of function f3
template<> inline double Spline::_eval_f3<0>(const double& x) const {
  return a3*std::pow(x, 5) + b3*std::pow(x, 4) + c3*std::pow(x, 3) + d3*std::pow(x,
      2) + e3*x + g3;
}

// template specialization for non-zero derivative 1 of function f3
template<> inline double Spline::_eval_f3<1>(const double& x) const {
  return 5*a3*std::pow(x, 4) + 4*b3*std::pow(x, 3) + 3*c3*std::pow(x, 2) + 2*d3*x
      + e3;
}

// template specialization for non-zero derivative 2 of function f3
template<> inline double Spline::_eval_f3<2>(const double& x) const {
  return 20*a3*std::pow(x, 3) + 12*b3*std::pow(x, 2) + 6*c3*x + 2*d3;
}

// template specialization for non-zero derivative 3 of function f3
template<> inline double Spline::_eval_f3<3>(const double& x) const {
  return 60*a3*std::pow(x, 2) + 24*b3*x + 6*c3;
}

// template specialization for non-zero derivative 4 of function f3
template<> inline double Spline::_eval_f3<4>(const double& x) const {
  return 120*a3*x + 24*b3;
}

// template specialization for non-zero derivative 5 of function f3
template<> inline double Spline::_eval_f3<5>(const double& x) const {
  return 120*a3;
}

// template specialization for non-zero derivative 0 of function f4
template<> inline double Spline::_eval_f4<0>(const double& x) const {
  return a4;
}

template<std::size_t N> double Spline::eval(const double& x) const {
  // this is a binary search through the junctions
  if (x <= j_f1_f2) {
    if (x <= j_f0_f1) {
      return _eval_f0<N>(x);
    }
    else {
      return _eval_f1<N>(x);
     }
  }
  else {
    if (x <= j_f2_f3) {
      return _eval_f2<N>(x);
    }
    else {
      if (x <= j_f3_f4) {
        return _eval_f3<N>(x);
      }
      else {
        return _eval_f4<N>(x);
       }
     }
   }
}

template<std::size_t N> double Spline::is_continuous(const double& epsilon) const {
  double left_sided_j_f0_f1 = _eval_f0<N>(j_f0_f1);
  double right_sided_j_f0_f1 = _eval_f1<N>(j_f0_f1);
  if (std::abs(left_sided_j_f0_f1 - right_sided_j_f0_f1) > epsilon) { return false; }
  double left_sided_j_f1_f2 = _eval_f1<N>(j_f1_f2);
  double right_sided_j_f1_f2 = _eval_f2<N>(j_f1_f2);
  if (std::abs(left_sided_j_f1_f2 - right_sided_j_f1_f2) > epsilon) { return false; }
  double left_sided_j_f2_f3 = _eval_f2<N>(j_f2_f3);
  double right_sided_j_f2_f3 = _eval_f3<N>(j_f2_f3);
  if (std::abs(left_sided_j_f2_f3 - right_sided_j_f2_f3) > epsilon) { return false; }
  double left_sided_j_f3_f4 = _eval_f3<N>(j_f3_f4);
  double right_sided_j_f3_f4 = _eval_f4<N>(j_f3_f4);
  if (std::abs(left_sided_j_f3_f4 - right_sided_j_f3_f4) > epsilon) { return false; }
  return true;
}

}
}
